## 1. 图片预处理

- 由于图像的预处理非常多方法，因此从数据预处理中抽出来
- 按照图像在视觉或设备中的成像效果，可以将图像分为：
  - 灰度图：也就是常说的黑白照片，单通道
  - 彩色图像：RGB、HSV、YUV、CMYK、Lab

## 2. 灰度变化

- 灰度变换是指将一幅图像的像素灰度值进行一定的映射变换，使得图像的亮度、对比度等属性得到调整，以达到某种特定的视觉效果
- 记录像素点的原始值为 s，灰度变换的映射函数为 T(s)，变换后的像素点为 d，即：
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/a112c0dd-7057-47d7-8ee4-96628acb7bca)
- 反转、对比度增强、对比度压缩和伽马矫正是常用的图像灰度变换方法

#### 2.1 线性变换

- 线性变换是一种简单的灰度变换方法，它将图像的灰度值进行线性映射，通常用下面的公式来表示：
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/7fe82065-e105-4476-918c-48625fea1931)
- 其中，f(x, y) 表示原图像的灰度值，g(x, y) 表示变换后的灰度值，a 和 b 是常数，可以通过调整它们来控制变换的幅度和方向

#### 2.2 对数变换

- 对数变换可以增强图像的暗部细节，通常用下面的公式来表示：
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/a157d6f9-d068-4bde-a0bc-dcadc6778ed5)
- 其中，f(x, y) 表示原图像的灰度值，g(x, y) 表示变换后的灰度值，c 是常数，可以通过调整它来控制变换的幅度

#### 2.3 幂律变换

- 幂律变换可以增强图像的亮部细节，通常用下面的公式来表示：
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/2bf8110a-38c4-49c4-81af-e949d45d19c7)
- 其中，f(x, y) 表示原图像的灰度值，g(x, y) 表示变换后的灰度值，c 和 γ 是常数，可以通过调整它们来控制变换的幅度和方向

#### 2.4 反转

- 反转是一种简单的灰度变换方法，它可以将图像中亮度值较高的区域变暗，将亮度值较低的区域变亮，从而实现对比度的增强。反转的实现方法很简单，只需要将每个像素的灰度值取反即可。例如，原图像中的像素灰度值为 g，反转后的像素灰度值 = 255 - g

#### 2.5 对比度增强

- 对比度增强是一种将图像中的灰度值重新映射到更广的范围内，从而增加图像的对比度的方法。对比度增强的实现方法有很多种，其中常用的方法有灰度拉伸，LUT（ 查找表 ）
- 灰度拉伸
  - 具体来说假设原图像的像素值范围为 [a, b]，将其线性拉伸到 [0, 255] 的范围内，拉伸函数可以表示为：
    ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/f5694ce0-487d-4332-b142-68e19295ebbb)
  - 其中，x 为原图像的像素值，g(x) 为拉伸后的像素值
- LUT
  - 计算拉伸函数 g(x)，其中 x ∈ [a, b]，a 和 b 分别为原图像的最小像素值和最大像素值
    ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/5672bdd9-1eea-4f4c-8ce6-3782a5f63af9)
  - 创建一个 256 个元素的查找表 lookup，其中 lookup(i) 表示原图像中像素值为 i 的像素在拉伸后的像素值
  - 遍历原图像的每个像素，查找表中查找对应的新像素值，将其赋值给输出图像

#### 2.6 对比度压缩

- 对比度压缩是一种将图像中的灰度值重新映射到更窄的范围内，从而减少图像的对比度的方法
- 对比度压缩的实现方法也有很多种，常用的方法是对数变换，LUT（ 查找表 ）
- 对数变化
  - 具体来说，对数变换将图像中的灰度值取对数后再缩放到 [0,255] 范围内，公式如下：
    ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/34064d67-d1cf-4342-ae97-ddf04a467326)
- LUT
  - 步骤和公式和上面的一样

#### 2.7 伽马矫正

- 伽马矫正是一种通过对图像中的灰度值进行非线性变换，从而调整图像亮度的方法。伽马矫正的原理是通过一个非线性函数来映射原图像中的灰度值，从而使得亮度值更低的区域变暗，亮度值更高的区域变亮
- 具体来说，伽马矫正使用公式：$g'=Ag^γ$
- 其中，g 表示原图像中的像素灰度值，g' 表示伽马矫正后的像素灰度值，A 和 γ 是参数。A 控制了灰度值的幅度，通常情况下 A = 1，γ 控制了灰度值变化的速度，通常情况下 γ 取值范围在 [0.5, 2.5] 之间
  - 当 γ 小于 1 时，图像中的亮度值较低的区域将被放大，从而提高了图像的对比度
  - 当 γ 大于 1 时，图像中的亮度值较高的区域将被放大，从而使图像更加明亮

## 3. 图像二值化（ image binarization ）

- 图像二值化是特殊的灰度变化，将图像上的像素点的灰度值全部设置为黑色 0 或白色 255，也就是将整个图像分割成明显的黑白效果的过程
- 最常用的是阈值分割，将图像中灰度值大于國值的像素点设置为白色（ 或黑色 ），小于國值的点设置为黑色（ 或白色 ），阈值 （ Threshold ）通常用 T 表示
- 由于阈值选取直接影响了二值化分割效果自适应阈值分割，如何选择合适的阈值是算法的核心，因此有一种通过算法自动计算出分割阈值方法叫自适应阈分割
- 常见的自适应阈值分割有双峰法和最大类间方差法

#### 3.1 双峰法

- 双峰法假定图像的灰度直方图是由两个峰值组成的。通过寻找直方图的两个峰值点，将它们的中间值作为阈值进行二值化。该方法适用于具有明显双峰分布的图像
- 算法步骤为
  - 对图像进行灰度化处理，获取灰度直方图
  - 寻找灰度直方图的两个峰值点。将两个峰值点的中间值作为阈值进行二值化

#### 3.2 最大类间方差法

- 最大类间方差法是一种自适应阈值的方法，它能够根据图像的局部灰度分布来自动选择合适的阈值
- 最大类间方差法的核心思想是将图像分成两类，使得这两类之间的方差最大。方差越大，说明两类之间的差异越明显，因此选择的阈值也越合适
- 具体实现步骤如下：
  - 统计图像的灰度直方图，得到每个灰度级的像素数量
  - 计算每个灰度级的权重，即该灰度级所占总像素数的比例
  - 从灰度级为 1 开始，循环计算每个灰度级的类间方差，即用该灰度级将图像分成两类后，两类之间的方差。方差计算公式为
    ![image](https://github.com/user-attachments/assets/6e4b5b4d-074d-4de7-bcf1-bbfaa5ba659f)
    - 其中 $ω_1$ 和 $ω_2$，分别为两类像素占总像素数的比例，$μ_1$ 和 $μ_2$ 分别为两类像素的平均灰度值，$μ_t$ 为总平均灰度值

## 4. 图像直方图

#### 4.1 直方图

- 直方图，是指对整个图像在灰度范围内的像素值（ 0 ~ 255 ）统计出现频率次数，据此生成的直方图，称为图像直方图。直方图反映了图像灰度的分布情况
- 直方图是图像的统计学特征，如果我们使用 RBG 分别对三个通道实现直方图，就那这三个直方图就代表这个图像的特征
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/734627cd-107e-4d92-b366-7050d82197e6)

#### 4.2 直方图均衡化

- 直方图均衡化是一种常见的图像增强方法，它通过对图像的像素值进行变换，使得像素值在整个灰度范围内分布均匀，从而增强图像的对比度
- 具体实现方法：
  - 计算原图像的灰度直方图
  - 计算灰度直方图的累积分布函数
  - 根据累积分布函数对原图像进行灰度值映射
  - 得到均衡化后的图像
- 具体而言，假设原图像的像素值范围为 [0, 255]，其灰度直方图为 H(i)，i ∈ [0, 255]，CDF 为 C(i)，i ∈ [0, 255]，均衡化后的像素值为 g(i)，i ∈ [0, 255]，则有
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/e8ee7a52-6db0-4c0d-9fb7-37aac3823899)
  - 其中，M MM 和 N NN 分别为原图像的宽度和高度。在 OpenCV 中，可以使用 equalizeHist()函数来实现直方图均衡化。需要注意的是，直方图均衡化有时会导致图像的噪声增强，因此在实际应用中需要谨慎使用
- 比如存在样例
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/8dda1827-f4c0-471f-ace5-69a7ead4602c)
- 均衡化转化后
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/333004c2-6e83-4087-8766-314c77225aff)
- 可以看到均衡化，是将直方图中的内容左右拉伸了一下，目的是让图像中像素领域之间差异显得不大，平衡整个图片的色彩，使观察图片时，不会发现某个地方色彩对比其他位置突出

## 5. 空间滤波（ 卷积计算 ）

- 空间滤波是一种基于图像局部邻域像素的图像处理方法，它通过对图像像素周围的邻域像素进行加权平均或其他数学运算来改变图像的特征
- 常见的空间滤波算法包括均值滤波、中值滤波、高斯滤波等
- 空间滤波的一般步骤如下：
  - 定义一个固定大小的滤波器（ 也称为卷积核或模板 ），滤波器通常是一个矩阵
  - 将滤波器中心对准当前像素，将滤波器中的所有元素与当前像素的邻域像素进行加权或其他数学运算，得到当前像素的输出值
  - 移动滤波器，重复步骤 2，直到所有像素都被处理过
- 使用不同的滤波器来实现图像像素的改变，其中的主要有三功能分别是图像模糊（ 去噪 ）、图像梯度（ 边缘发现 ）、图像锐化（ 凸图像增强 ），这里都把这些功能都看成是图像增强， 因为这些操作都是修改了图像的像素

#### 5.1 均值滤波

- 均值滤波是指用当前像素点周围 N\* N 个像素点的均值来代替当前像素值
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/e8ab2c48-4cd8-4c01-8503-99c9aac3dda3)

#### 5.2 高斯滤波

- 在进行均值滤波与方框滤波时，其邻域内每个像素的权重是相等的。而高斯滤波会将中心点的权重加大，远离中心点的权重减小，以此来计算邻域内各个像素值不同权重的和

#### 5.3 中值滤波

- 用邻域内所有像素值的中间值来代替当前像素点的像素值

#### 5.4 双边滤波

- 双边滤波是一种非线性的滤波方法，它在平滑图像的同时保留了边缘信息。其核心思想是通过对像素点的空间位置和像素值之间的相似度进行加权平均，来达到滤波的效果
- 双边滤波公式为：
  ![image](https://github.com/user-attachments/assets/3f8139b0-623f-4947-ada7-6ea352bb736a)

#### 5.5 边缘锐化

- 图像梯度计算可以作为边缘检测的基础，边缘通常是图像梯度变化较大的地方。对于图像的边缘部分，其灰度值变化较大，梯度值也较大；相反，对于图像中比较平滑的部分，其灰度值变化较小，相应的梯度值也较小
- 其实梯度就是导数，但是图像梯度一般通过计算像素值的差来得到梯度的近似值，也可以说是近似导数。该导数可以用微积分来表示
- 在线性代数微积分中，一维函数一阶微分定义
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/c99ef07d-cd33-4949-836b-b161b1ec2b04)
- 在图像中就是一个二维函数 f(x, y)，有二个方向，一个 x 方向一个 y 方向，因此需要做偏微分
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/6da3d048-e006-436c-8e5b-21ef231a0e6b)
- 那个这个二维函数总的梯度就为
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/18be6746-0869-4e33-bacc-4a3057c3adc5)
- 每一个像素的梯度是由它周围 8 个像素共同确定的
- 要想计算出图像的边缘的基本特征，就需要类似的空间滤波，在这里空间滤波也叫它算子，主要用于计算边缘的算子有 Sobel、Robort、Laplacian

#### 5.6 Roberts 算子

- Roberts 算子又称为交叉微分算法，它是基于交叉差分的梯度算法，通过局部差分计算检测边缘线条。常用来处理具有陡峭的低噪声图像，当图像边缘接近于正 45 度或负 45 度时，该算法处理效果更理想。其缺点是对边缘的定位不太准确，提取的边缘线条较粗
- Roberts 算子的模板分为水平方向和垂直方向，如下式所示，从其模板可以看出，Roberts 算子能较好的增强正负 45 度的图像边缘
- Roberts x 方向算子模版
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/d70875ca-a532-46e0-8570-6fac8f016979)
- Roberts y 方向算子模版
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/231fc00c-937d-4b96-84dc-7a2e9c4d1bd6)

#### 5.7 Prewitt 算子

- Prewitt 算子是一种图像边缘检测的微分算子，其原理是利用特定区域内像素灰度值产生的差分实现边缘检测
- 由于 Prewitt 算子采用 3 \* 3 模板对区域内的像素值进行计算，而 Robert 算子的模板为 2 \* 2，故 Prewitt 算子的边缘检测结果在水平方向和垂直方向均比 Robert 算子更加明显。Prewitt 算子适合用来识别噪声较多、灰度渐变的图像
- Prewitt x 方向算子模版
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/404b5d58-7b4e-4b6b-85ef-3fcc4e5426c1)
- Prewitt y 方向算子模版
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/be2d737e-fb47-411f-9969-b893d3802ef1)

#### 5.8 Sobel 算子

- Sobel 算子是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导
- 该算子用于计算图像明暗程度近似值，根据图像边缘旁边明暗程度把该区域内超过某个数的特定点记为边缘
- Sobel 算子在 Prewitt 算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓
- Sobel 算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。因为 Sobel 算子结合了高斯平滑和微分求导（ 分化 ），因此结果会具有更多的抗噪性，当对精度要求不是很高时，Sobel 算子是一种较为常用的边缘检测方法
- Sobel 算子的边缘定位更准确，常用于噪声较多、灰度渐变的图像。其算法模板如下面的公式所示，其中 表示水平方向， 表示垂直方向
- Sobel x 方向算子模版
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/32c1b9a7-2058-4f18-9464-03998dda5b1e)
- Sobel y 方向算子模版
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/e147fe8f-50c0-4b19-b9bd-b852e409be98)

#### 5.9 Laplacian 算子

- 拉普拉斯（ Laplacian ）算子是 n 维欧几里德空间中的一个二阶微分算子，常用于图像增强领域和边缘提取。它通过灰度差分计算邻域内的像素
- 算法基本流程
  - 判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作
  - 在算法实现过程中，Laplacian 算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系
  - 最后通过梯度运算的结果对像素灰度进行调整
- Laplacian 算子分为四邻域和八邻域，四邻域是对邻域中心像素的四个方向求梯度，八邻域是对八个方向求梯
- Laplacian 算子四邻域模板如下所示
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/ff28a7c7-afd2-4317-a63f-277fe16e4765)
- Laplacian 算子的八邻域模板如下所示
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/42fc9d0e-8af9-4692-bfdc-eaa742f258d7)
- 通过 Laplacian 算子的模板可以发现
  - 当邻域内像素灰度相同时，模板的卷积运算结果为 0
  - 当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数
  - 当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理

#### 5.10 不同算子比较

- Robert 算子对陡峭的低噪声图像效果较好，尤其是边缘正负 45 度较多的图像，但定位准确率较差
  - Roberts 算子利用局部差分算子寻找边缘，边缘定位精度较高，但容易丢失一部分边缘，不具备抑制噪声的能力。该算子对具有陡峭边缘且含噪声少的图像效果较好，尤其是边缘正负 45 度较多的图像，但定位准确率较差
- Prewitt 算子对灰度渐变的图像边缘提取效果较好，而没有考虑相邻点的距离远近对当前像素点的影响
  - Prewitt 算子对灰度渐变的图像边缘提取效果较好，而没有考虑相邻点的距离远近对当前像素点的影响，与 Sobel 算子类似，不同的是在平滑部分的权重大小有些差异
- Sobel 算子考虑了综合因素，对噪声较多的图像处理效果更好
  - Sobel 算子考虑了综合因素，对噪声较多的图像处理效果更好，Sobel 算子边缘定位效果不错，但检测出的边缘容易出现多像素宽度
- Laplacian 算子对噪声比较敏感，由于其算法可能会出现双像素边界，常用来判断边缘像素位于图像的明区或暗区，很少用于边缘检测
  - Laplacian 算子不依赖于边缘方向的二阶微分算子，对图像中的阶跃型边缘点定位准确，该算子对噪声非常敏感，它使噪声成分得到加强，这两个特性使得该算子容易丢失一部分边缘的方向信息，造成一些不连续的检测边缘，同时抗噪声能力比较差，由于其算法可能会出现双像素边界，常用来判断边缘像素位于图像的明区或暗区，很少用于边缘检测
- 举例
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/da4cdd0c-00ac-458a-a326-46cf9c25d0a4)
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/44b9b0f4-9410-4cc1-b8ef-84303526e6ee)
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/c522df1b-eeb6-4e16-915a-0bf1dd70cd0d)
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/72606028-de06-4332-a6ee-2724473c53bb)

## 6. 形态学处理

#### 6.1 腐蚀与膨胀

- 腐蚀与膨胀是图像形态学的核心操作
  - 腐蚀：对图像中的内容沿着边界，向内收缩（ 把图像中的线条变细，去掉一部分线条的像素值 ）
  - 膨胀：对图像中的内容沿着边界，向内扩展（ 把图像中的线条变粗，增加一部分线条的像素值 ）
- 这两种操作的逻辑和作用都和使用滤波器做平滑处理有些类似，不同之处在于，腐蚀求的是滤波核内像素的最小值，而膨胀求的是最大值，并将计算出的值复制给锚点位置的像素

#### 6.2 开运算与闭运算

- 开运算就是将图像先进行腐蚀操作，再进行膨胀操作，其可以用来抹除图像外部的细节（ 噪声 ）
- 闭运算是先对图像进行膨胀操作，在进行腐蚀操作，其可以用来抹除图像的内部细节（ 噪声 ）

## 7. 坐标变换

- 图像的坐标变换又被称为图像的几何计算，常见的基本变换有：图像平移、镜像、缩放、旋转、仿射。常用于数据增强
- 平移转换矩阵
  ![image](https://github.com/user-attachments/assets/451bf2d6-2023-457e-b870-05762e4da1de)
- 旋转转换矩阵
  ![image](https://github.com/user-attachments/assets/d83a7464-b1f8-4f3d-80ac-d9245fb9a176)
- 缩放转换矩阵
  ![image](https://github.com/user-attachments/assets/83716ae2-c72b-4507-bf38-425287d30d07)
- 镜像
  - 水平镜像，x 位置不变，只反转 y 位置
    ![image](https://github.com/user-attachments/assets/eed92294-e732-4af1-822d-a01336f95890)
  - 垂直镜像，y 位置不变，只反转 x 位置
    ![image](https://github.com/user-attachments/assets/54d0f85a-d81c-41a1-a801-7d72692012cd)
  - 对角镜像，x，y 位置都反转
    ![image](https://github.com/user-attachments/assets/c5723d53-8979-49e4-a20b-5a5d60ab916f)
- 图像缩放
  - 在 opencv 中通常用图像金字塔用来进行图像缩放的，与 resize 函数类似
  - 其中图像金字塔根据方法可以分成为：
    - 高斯金字塔：缩小图像也叫下采样，用 PryDown 函数
    - 拉普斯金字塔：放大图像也叫上采样，用 PryUp 函数

## 8. 特征描述子

- 特征描述子是图像处理和计算机视觉中一种用于描述图像局部特征的算法。它是一种将图像中的特征点表示为数学向量的技术，可以用于图像匹配、目标检测和识别等应用
- 特征描述子的算法原理通常包括以下步骤：
  - 特征点检测：首先需要在图像中检测出具有独特性和区分度的局部特征点，例如角点、边缘、斑点等
  - 特征点描述：对于每个特征点，需要计算其周围像素的特征值或特征向量，例如梯度方向、颜色、纹理等，用于描述该特征点的局部特征
  - 特征点匹配：通过比较不同图像中的特征点描述子，可以进行特征点的匹配，用于图像配准、目标跟踪和识别等任务
- 常用的特征描述子：
  - SIFT（ Scale-Invariant Feature Transform ）：尺度不变特征变换，是一种基于局部特征的描述子。SIFT 描述子是通过计算关键点周围的梯度方向直方图来生成的，具有尺度不变性和旋转不变性
  - SURF（ Speeded Up Robust Features ）：SURF 是 SIFT 的加速版，它采用了一些近似算法来加快计算速度，并具有与 SIFT 类似的尺度不变性和旋转不变性
  - ORB（ Oriented FAST and Rotated BRIEF ）：ORB 是一种计算速度较快的特征描述子，它是基于 FAST 角点检测器和 BRIEF 二进制描述子的改进版本。ORB 描述子具有旋转不变性和尺度不变性
  - HOG（ Histogram of Oriented Gradients ）：HOG 是一种用于目标检测和分类的特征描述子。它是通过计算图像中的梯度方向直方图来生成的，具有方向性和尺度不变性
  - LBP（ Local Binary Patterns ）：LBP 是一种局部特征描述子，它是通过计算图像中每个像素与其邻域像素之间的差异来生成的。LBP 描述子具有旋转不变性和灰度不变性
