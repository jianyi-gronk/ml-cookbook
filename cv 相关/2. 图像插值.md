## 1. 图像插值

- 插值指的是利用已知数据去预测未知数据，图像插值则是给定一个像素点，根据它周围像素点的信息来对该像素点的值进行预测
- 当调整图片尺寸或者对图片变形的时候常会用到图片插值。比如想把一个 4 \* 4 的图片变成 7 \* 7 的图片， 就会产生一些新的像素点（ 如下图红点所示）
  ![image](https://github.com/user-attachments/assets/8e528433-704a-4d55-8d82-1dc3b8f2ad97)
- 图像插值方法主要分为传统的插值算法和基于深度学习的插值算法两类
  - 传统的插值算法：最近邻，线性插值，双线性插值，双三次插值
  - 基于深度学习的插值算法：反卷积，亚像素上采样

## 2. 传统的插值算法

#### 2.1 最近邻（ Nearest interpolation ）

- 选取离目标点最近的点的值（ 原来就存在的点 ）作为新的插入点的值
  ![image](https://github.com/user-attachments/assets/62e2fd29-6c65-478a-80e3-fd3038d1ddf6)
- 从 3 \* 3 转换成 7 \* 7 的图片
  ![image](https://github.com/user-attachments/assets/ba8c9de4-28f8-4d8b-9455-0149dfc960c0)
- 最近邻插值是一种简单而快速的插值方法，但它在处理浮点坐标时会产生像素级别的不连续性，导致锯齿边缘和严重的失真，特别是在图像放大和缩小时
- 最近邻插值的原理简单直接，但在处理浮点坐标时，它会导致不连续的效果，尤其是在放大时，因为每个目标像素都是从源图像中的一个点复制而来，没有考虑到周围像素的信息，从而造成了锯齿状边缘和明显的失真
- 相对于最近邻插值，更复杂的插值方法如双线性插值和双三次插值考虑了邻近像素的权重，通过加权平均来计算目标像素的值，从而更平滑地处理图像缩放

#### 2.2 线性插值（ Linear interpolation ）

- 双线性插值，选取最近的两个点做计算
- 下图是一个一维的线性插值的定性示意图，坐标轴上各点 xi-1，xi，xi+1 ... 的值，两两直接相连为线段，从而构成了一条连续的约束函数。而插值坐标点例如 x，根据约束函数其值应为 f(x)。因为每两个坐标点之间的约束函数曲线是一次线性的线段，对插值结果而言是“线性” 的，所以该方法称为线性插值
  ![image](https://github.com/user-attachments/assets/61eac671-7912-4f50-858c-e314d1469f63)
- 下图是一个一维线性插值的定量示意图
  ![image](https://github.com/user-attachments/assets/a1abcc91-a3ec-40fd-a75d-357939885917)
- x0 和 x1 都是原有的坐标点，灰度值分别对应为 y0 和 y1。而灰度值未知的插值点 x，根据线性插值法约束，在 (x0, y0) 和 (x1, y1) 构成的一次函数上，其灰度值 y 即为
  ![image](https://github.com/user-attachments/assets/d7d51338-7fd3-4083-8644-00f5554ce4d6)
- 实际上，即便 x 不在 x0 与 x1 之间，该公式也成立，但此时这种方法叫线性外插

#### 2.3 双线性插值（ Bilinear interpolation ）

- 双线性插值，选取最近的四个点做计算
- 由一维的线性插值很容易拓展到二维图像的双线性插值，每次需要要经过三次一阶线性插值才能获得最终结果，该过程如下
  ![image](https://github.com/user-attachments/assets/e358e7cb-c826-474c-9fdd-7305e847cbd5)
  - 其中，(x0, y0)、(x0, y1)、(x1, y0)、(x1, y1) 均为原图像上的像素坐标点，灰度值分别对应为 f(x0, y0)、f(x0, y1)、f(x1, y0)、f(x1, y1)，而灰度值未知的插值点 (x, y)
  - 可以先由像素坐标点 (x0, y0) 和 (x0, y1) 在 y 轴向作一维线性插值得到 f(x0, y)、由像素坐标点 (x1, y0) 和 (x1, y1) 在 y 轴向作一维线性插值得到 f(x1, y)
  - 然后再由 (x0, y) 和 (x1, y) 在 x 轴向作一维线性插值得到插值点 (x, y) 的灰度值 f(x, y)
  - 当然，一维线性插值先作 x 轴向再作 y 轴向，得到的结果完全相同，仅为顺序先后的区别
- 下图是一个二维双线性插值的定量俯视示意图（ 点位稍有变动但不影响 ）
  ![image](https://github.com/user-attachments/assets/21344809-d78b-49a6-bd21-524ac0c1bfe0)
- 换个顺序，先由像素坐标点 (x0, y0) 和 (x1, y0) 在 x 轴向作一维线性插值得到 f(x, y0)、由像素坐标点 (x0, y1) 和 (x1, y1) 在 x 轴向作一维线性插值得到 f(x, y1)
  ![image](https://github.com/user-attachments/assets/b457cc40-7771-4b0b-92e1-f702fa4864c6)
- 然后再由 (x, y0) 和 (x, y1) 在 y 轴向作一维线性插值得到插值点 (x, y) 的灰度值 f(x, y)  
  ![image](https://github.com/user-attachments/assets/82fdbbea-dfa0-4f44-8fec-197f37a29758)
- 得到最终的双线性插值结果
  ![image](https://github.com/user-attachments/assets/b5e80d91-a188-4a43-b771-f26cc2fe6033)

#### 2.4 双三次插值（ Bicubic interpolation，又称 立方卷积插值，双立方插值 ）

- 双三次插值是二维空间中最常用的插值方法，在这种方法中，插值点 (x, y) 的像素灰度值 f(x, y) 通过矩形网格中 最近的十六个采样点的加权平均 得到，而 各采样点的权重由该点到待求插值点的距离确定，此距离包括 水平和竖直 两个方向上的距离
- 下图是一个二维图像的双三次插值俯视示意图
  ![image](https://github.com/user-attachments/assets/eee2a4bf-8114-4783-8cc9-968effe7eb6c)
  - 设待求插值点坐标为 (i+u, j+v)，已知其周围的 16 个像素坐标点的灰度值，还需要计算 16 个点各自的权重
  - 以像素坐标点 (i, j) 为例，因为该点在 y 轴和 x 轴方向上与待求插值点 (i+u, j+v) 的距离分别为 u 和 v，所以的权重为 w(u) \* w(v)，其中 w(·) 是插值权重核（ 可以理解为定义的权重函数 ），同理可得其余 15 个像素坐标点各自的权重
- 插值权重核 w(·) 通常为
  ![image](https://github.com/user-attachments/assets/38799774-39a2-42f9-af5a-77543a7ce215)
- 其函数图像如下所示
  ![image](https://github.com/user-attachments/assets/de110dcd-8a47-4fbe-a43f-dd7d7bfd15ed)

## 3. 基于深度学习的插值算法

#### 3.1 反卷积（ Transposed Convolution ）

- 反卷积是种特殊的卷积，总是可以使用一种卷积来模拟反卷积的过程。该方式将引入许多 ‘0’ 的行和 ‘0’ 的列，导致实现上非常的低效
- 并且，反卷积只能恢复尺寸，并不能恢复到卷积前数值，因此经常用在神经网络中只作为提供恢复的尺寸，具体的卷积参数数值往往通过训练得到

#### 3.2 亚像素上采样（ Pixel Shuffle ）

- 传统的上采样主要考虑空间因素，没有考虑 channel 因素，上采样的特征图人为修改痕迹明显，图像分割与 GAN 生成图像中效果不好。为了解决这个问题，ESPCN 中提到了亚像素上采样方式。具体原理如下
  ![image](https://github.com/user-attachments/assets/94285849-e41e-4a16-9fd8-08680d4388ea)
- 根据上图，可以得出将维度为 [B, C, H, W] 的 feature map 通过亚像素上采样的方式恢复到维度 [B, C, sH,sW ] 的过程分为两步
  ![image](https://github.com/user-attachments/assets/bd0fc476-6b7b-41a2-b2c1-ca11ec113ff2)
- Pixel Shuffle 的主要功能就是将这 $s^2$ 个通道的特征图组合为新的 [B, C, sH, sW] 的上采样结果。具体来说，就是将原来一个低分辨的像素划分为 $s^2$ 个更小的格子，利用 $s^2$ 个特征图对应位置的值按照一定的规则来填充这些小格子。按照同样的规则将每个低分辨像素划分出的小格子填满就完成了重组过程。在这一过程中模型可以调整 $s^2$ 个 shuffle 通道权重不断优化生成的结果
